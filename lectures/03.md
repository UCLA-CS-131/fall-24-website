---
title: "03. Func. Programming 1"
week: 2
original_author: Einar Balan, Matt Wang
originally_written: 2024-09-24
lecture_date: 2024-10-07
author: Einar Balan
layout: lecture
parent: Lecture Notes
---

{: .note }
This covers the first 46 slides of the Intro to Functional Programming deck.

## Table of Contents
{: .no_toc }

{:toc}
- dummy item

## What is Functional Programming?

Functional programming is defined by several key tenets:

- every function must **take an argument** (or more than one)
    - C-type `main()` functions are forbidden
- every function must return a value
    - C-type functions of type `void` are forbidden
- functions are **pure**: they should have no side effects
  - side effects include changing global variables, input/output, print statements, etc.
  - *the most important tenet!*
- calling a function `f(x)` with the same argument `x` should **always return the same output `y`** [^1]
- variables are **immutable**: after declaration, they cannot be modified
  - ex: `f(x){ x = x + 1; return x }` is not allowed!
- functions are **first-class** - just like other values, they can be stored as variables, passed as arguments, etc.

[^1]: In other words, functions are deterministic.

More rigorously:, a **pure function** has two core properties:

1. It doesn't depend on any data other than its inputs to compute a result
2. It doesn't modify any data beyond initializing local variables required to compute its output

Sometimes, this is called a **referentially transparent function**.

This function is pure: it only depends on `p`, and the only variable it initializes is never re-assigned (i.e., it's just to help us with naming).

```cpp
int f(int p) {
 int q = 5 * p * p;
 return q;
}
```

This function is **not pure**: not only does it depend on a global variable `z` (not an input to the function), but it also modifies it during the computation!

```cpp
int z;
int f(int p) {
  return p * z++;
}
```

There are a few **consequences** resulting from these basic tenets:
- no random numbers can be generated or used
    - since that would violate determinism
- no input is taken in a compiled Haskell programme
    - since that would violate determinism (input will determine result produced)
- no output is produced (aside from the final product) in a compiled Haskell programme
    - since that would not longer be pure (we are altering program state)

### Functional versus Imperative

Let's compare and contrast!

Imperative programs:

- are sequences of statements, loops, and function calls - they operate sequentially
- require changes in variable state
- as a result, multi-threading can be tricky, since there's shared mutable state and thus race conditions
- the order of execution matters!

Functional programs have different paradigms:

- at the core, functional programs are **only composition of functions** - no loops, statements, etc.
- no changes in variable state are allowed
- multi-threading is trivial: there is no shared mutable state (since mutability is not allowed)!
- and, interestingly, **the order of execution is not important**

What does that last point mean? Under the hood, it's all about side effects.

In an imperative language, calling functions in different orders can have side effects. Consider this example:

```cpp
int global = 0;

int func1(int arg) {
 return arg + global++;
}

int func2(int arg) {
  return arg * global;
}

int func(int arg) {
  int y = func1(arg);
  int z = func2(arg);

  if (z == 7)
    return 0;
  else return y;
}
```

In `func`, even though the declarations of `y` and `z` seem to not depend on each other - calling them in different orders matters!

- if we were to run `int y = func1(arg)` first, then `global` gets incremented to `1`, which *changes `z`'s behaviour*!
- if we were to run `int z = func(arg)` first, then `global` stays at `0`, and `z` returns `0`!

Functional programming disallows code like what we just saw; so, we really could evaluate `y` and `z` in any order!

## Intro to Haskell

Haskell is one of the first (and earliest) pure functional languages. This means that it is one of the best embodiments of functional programming design goals with minimal features from other paradigms. While it has many restrictions - like requiring generally pure functions - it really lets us learn functional programming!

### Our First Program

After [installing Haskell](https://www.haskell.org/ghc/download.html), we can run the interactive interpreter with `ghci`:

```sh
$ ghci
```

(you can exit this with `Ctrl+D`)

In a separate window, let's make a file - `hypot.hs` (note the file extension)

```hs
-- hypot.hs
hypot a b = sqrt((a^2) + (b^2))
```

{: .note }
`--` is how you declare a comment in Haskell.

We can now load this in `ghci`:

```console
$ ghci
GHCi, version 9.2.4: https://www.haskell.org/ghc/  :? for help
ghci> :load hypot
[1 of 1] Compiling Main             ( hypot.hs, interpreted )
Ok, one module loaded.
ghci> hypot 3 4
5.0
```

Let's say we update our file:

```hs
-- hypot.hs
square x = x * x
hypot a b = sqrt (square a + square b)
```

We can reload this file with `:r`:

```console
ghci> :r
[1 of 1] Compiling Main             ( hypot.hs, interpreted )
Ok, one module loaded.
ghci> hypot 7 8
10.63014581273465
```

We can also define functions in the interpreter itself:

```console
ghci> :{
ghci> squareArea :: Double -> Double
ghci> squareArea    side   =  side^2
ghci> :}
ghci> squareArea 4.0
16.0
```
Notice how we used `:{` and `:}` to define a multiline input. 

## Basic Haskell: Challenge by Challenge

Let's learn Haskell through a series of challenges. We'll show you some code and your job is to try figure either how it works or what its output is! By the end, you'll know a lot more about Haskell and you'll be ready to start writing your own basic programs. Let's get into it!

As we start, you should be aware that Haskell is very different from anything you've been exposed to in the past. Don't worry if it doesn't make sense at first! We (the entire teaching team) are here to support you in lecture, discussion, and office hours. That being said, if you're curious about how certain parts of the language work, the best way to learn is to simply try it in `ghci`. 

Okay! Now let's really get into it with our first challenge.

### Simple Functions 

Here's a Haskell function that computes 3x^2.

```haskell
-- polynomial.hs
poly :: Double -> Double
poly x = 3 * x^2
```

And here's the C++ equivalent:

```cpp
// polynomial.cpp
double poly(double x) {
  return 3 * x*x;
}
```

We can load `polynomial.hs` into `ghci` as follows:
```console
ghci> :load polynomial
ghci> poly 2
12
```

Some things to notice:
1. We specified the type of the function poly on the line before the actual function definition. In plain English, you can read it as a function that takes an argument of type Double and returns a Double. 
2. We don't include parenthesis around parameters like in other languages.
3. The body of the function is a simple expression following an equal sign!
4. There is no return statement.
5. To call a function we just specify its name and parameters.

In case you were curious, you can also define a main function in Haskell!

```haskell
-- polynomial.hs
poly :: Double -> Double
poly x = 3 * x^2

main :: IO()
main = do 
    let result = poly 5
    putStrLn ("Result: " ++ show result)
```

This is beyond the scope of the class, but it can be useful for things like writing test cases etc. An important note is that the `putStrLn` function is essentially a print function. You might be wondering: *how is that possible if side effects aren't allowed in Haskell?* Output is definitely a side effect!

In short, since we defined main to be a special type `IO()`, Haskell can work around the side effect constraint through some pretty cool and complex math.[^3]

[^3]: If you're curious about learning more, you should look into monads and the IO monad in particular. If you prefer written resources, read the Learn You a Haskell chapters on [IO](http://learnyouahaskell.com/input-and-output) and [Monads](http://learnyouahaskell.com/a-fistful-of-monads), or Galen Wong's wonderful [CS 231 notes](https://galenwong.github.io/blog/2021-08-29-cs231-notes/). [Here](https://www.youtube.com/watch?v=Q0aVbqim5pE) is a good video on monads in general and [here](https://www.youtube.com/watch?v=fCoQb-zqYDI) is a video explaining the IO monad in particular. As a warning, these topics are complicated so it may take a while for them to truly sink in, but it is super interesting! 

But most of the time in this class you'll just be writing functions and calling them from the interpreter directly.

### Parameters 

Consider this function:

```haskell
-- greater.hs
is_greater :: Int ->  Int  -> Bool
is_greater   first  second =  
    first > second
```

And the C++ equivalent:

```cpp
// greater.cpp
bool is_greater(int first, int second) {
  return first > second;
}
```

It determines if the first parameter is greater than the second. Here it is in action:

```console
ghci> :load greater
ghci> is_greater 2 5
False
ghci> is_greater 12 8
True
```

Some things to notice:
1. All but the last type in a function's type signature refer to the types of the parameters.
2. The last type is the return type.
3. We can use multiple lines for a function as long as we indent.
4. There are no parentheses or commas in a function call.

### Types 

Consider the following function:

```haskell
-- old.hs
is_old age has_aches =
    (age > (30::Int)) || (has_aches == True)
```
Notice that it has no explicit type definition. Let's mess around with it a bit in `ghci`.

```console
ghci> :load old
Ok, one module loaded.
ghci> is_old 20 True
True
ghci> :t is_old
is_old :: Int -> Bool -> Bool
ghci> is_old 53.5 False
<interactive>:3:8: error:
• No instance for (Fractional Int) arising from the literal ‘53.5’
```

Some things to notice:
1. We can use `:t` to get the type of a value in Haskell. 
2. In this case, Haskell was able to *infer* the types of all the parameters and the output of the function. Pretty cool! Haskell is able to deduce the types based on the operations used in the function. For example, since we compared `age` to an `Int`, `age` must also be an `Int`! The same logic can be used to determine the type of `has_aches` and the return type.

It's important to understand that just because variable types are not explicitly defined, does NOT mean the variables do not have types. In Haskell, all types are fixed and determined at compile time! Consider the error above. You can't pass a `Double` to a parameter of type `Int`!

So ... why would we even use type declarations? Unlike who we're insulting, it's **good hygiene** (and, best practice)!
- type declarations can provide better compiler warnings and errors
- type declarations make your code **easier to read**, arguably the most important trait in software![^10]
- and, it can help you think about how to write the function itself!

[^10]: The person reading it might be you six months later!

So, we recommend that you annotate your functions - or at least, the user-facing/top-level ones!

### Prefix Notation 

Consider this variation of `poly` from before.

```haskell
-- polynomial.hs
poly :: Double -> Double
poly x  =  (*) 3 x^2
```

It looks strange... what's going on here? In short, Haskell allows us to convert any operator to a prefix operator (i.e. a standard Haskell function) by adding parenthesis around it.[^4] 

Here are some more examples:

| Infix | Prefix |
|-------|--------|
| `6 - 5` | `(-) 6 5`|
| `5 + 6 / 2` | `(+) 5 ((/) 6 2)`|
| `a == b` | `(==) a b`|
| `x || y` | `(||) x y`|

[^4]: Interestingly, the reverse is also true! You can convert any function to an infix operator by adding surrounding backticks.

### Calling Functions

Let's talk a bit more about calling functions in Haskell. Consider the following functions:

```haskell
-- funcs.hs
f :: Int -> Int
f x = x^2

g :: Int -> Int
g x = 3*x
```

What do you think is the result of the following expressions and why?

```haskell
y = f g 2
z = f 5 * 10
```

<details>
<summary><b>Answer</b></summary>
<br><br>

Evaluating y results in a syntax error and z evaluates to 250! This might not be what you initially expected. You might think <code>f g 2</code> computes <code>f(g(2))</code>, but its important to understand that Haskell function calls are left associative. This means that <code>f g 2</code> should be interpreted as passing the function g to f as the first argument (e.g. (f g) 2), which clearly will lead to a type error! To fix this, we can add parenthesis: <code>f (g 2)</code>.
<br> <br>
Similar logic can be applied to understand why z is 250 instead of 2500 (e.g. <code>f(5 * 10))</code>. In Haskell, functions have higher precedence than operators, so they're always evaluated first. f takes 5 as its first argument and returns 25. This is then multiplied by 10 to get 250 (e.g. <code>(f 5) * 10</code>). 
<br> <br>
Carey includes a handy table to translate math to haskell expression on slide 21.
</details>

#### Calling Functions Challenge
{: .no_toc }

Below are defintions for a function f and a partially completed function g. Our goal is to have function g return the following: `f(a, sqrt(a+`))`. Complete the body of g using the minimum number of parentheses.

```haskell
f :: Double -> Double -> Double
f x y = x * y

g :: Double -> Double
g a = __________________
```
<details>
<summary><b>Answer</b></summary>
<pre>
g a = f a (sqrt (a+1))
</pre>
</details>

### If Expressions 

The general syntax of the `if` expression is:

```hs
if <expression> then <expression>
                else <expression>
```

Here's a concrete example:

```haskell
bruin_discount :: Int -> Int 
bruin_discount price = 
    if price > 100 
    then price - 20 
    else price - 10
```

Haskell's if expression is required to have an else clause. Why?

This is because if is *not* a statement like in an imperative language. It's an expression, so it must return a value! As a result every possible case needs to be covered with a return value and an else clause is required!

{: .note}
Think about how `if`-`then`-`else` works with types - if the two branches had different types, we'd break some of Haskell's type rules. This formalizes the above argument - why is that?

### Guards 

Consider the below program that uses another control flow mechanism in Haskell: guards!

```haskell
-- exam.hs
evaluateExam :: Int -> String -> String
evaluateExam    score  prof
  | score < 50 && prof == "Eggert" = 
    "Given the curve, you got a B+."
  | score < 50 = 
    "You got an F."
  | score == 100 = 
     impress prof
  | otherwise = 
     "You passed."


impress :: String -> String
impress prof = prof ++ " is impressed!"
```

Let's run the code:

```console
ghci> :load exam
Ok, one module loaded.
ghci> evaluateExam 30 "Eggert"
"Given the curve, you got a B+"
ghci> evaluateExam 30 "Nachenberg"
"You got an F."
ghci> evaluateExam 100 "Eggert"
"Eggert is impressed!"
```

As you can see, guards provide a cleaner syntax to handle multiple conditions.

Some things to notice:
1. There is no equal sign after the final parameter!
2. Each condition follows the format `| condition = expression`.
3. Conditons are evaluted from top to bottom.
4. The keyword `otherwise` is used as the else condition. [^5]
5. Guards are a form of syntactic sugar for if/else statements. They are functionally identical but are a lot easier to read and write.

[^5]: An interesting note is that the `otherwise` keyword is simply an alias for `True`. That's why guards always return the final condition. You could replace `otherwise` with `True` and it would function exactly the same (but that doesn't look as nice).

#### Guards Challenge
{: .no_toc }

Fill in the blanks to create the factorial function using guards.

```haskell
fact :: Int -> Int
fact n 
  | _________ = _________
  | _________ = ______________
```

<details>
<summary><b>Answer</b></summary>
<pre>
fact :: Int -> Int
fact n 
  | n == 0    = 1
  | otherwise = n * fact (n - 1)
</pre>
</details>

Carey provides a nice animation tracing through `fact` on slide 28!

### Local Bindings

Consider the following which uses a *let expression*:

```haskell
-- A function to get your nerdiness level
get_nerd_status gpa study_hrs = 
  let 
      gpa_part = 1 / (4.01 - gpa)
      study_part = study_hrs * 10     
      nerd_score = gpa_part + study_part
  in  
      if nerd_score > 100 then
           "You are super nerdy!"
      else "You're a nerd poser."
```

`let` allows you to define one or more *bindings*. One way to think of them is as local variables! For example, above you can see the name `gpa_part` is bound to `1 / (4.01 - gpa)`. Once we define our bindings, we can use their names to refer to their values in the function body (following the `in` keyword).

Haskell has another way to assign local bindings through the `where` construct. Here's an example:

```haskell
-- A function to get your nerdiness level
get_nerd_status gpa study_hrs = 
  if nerd_score > 100
     then "You are super nerdy!"
     else "You're a nerd poser."
  where
      gpa_part = 1 / (4.01 - gpa)
      study_part = study_hrs * 10     
      nerd_score = gpa_part + study_part

```
As you can see, with `where` the bindings follow the body of the function. A rule of thumb as to when you should choose `let` vs `where`: when defining a variable for a single expression use `let` and for multiple use `where`.

{: .note }
The second case is mainly for *guards*. You can technically still use `let` with guards but it leads to a lot of duplicated and ugly looking code. Use `where`!

#### Nested Functions
{: .no_toc }

Local bindings are not limited to variables (as one would expect in a functional language). You can define nested functions as follows:

```haskell
-- Function to describe someone's behavior
whats_the_behavior_of name = 
 if name == "Carey"
    then behaves_like name "twelve year-old"
    else behaves_like name "grown-up"
 where
  behaves_like n what = 
      n ++ " behaves like a " ++ what ++ "!"
```

We can actually refine this code further! Nested functions have visibility into all of a functions variables, so we don't need to pass in the name. We can just refer to it directly!

```haskell
-- Function to describe someone's behavior
whats_the_behavior_of name = 
 if name == "Carey"
    then behaves_like "twelve year-old"
    else behaves_like "grown-up"
 where
  behaves_like what = 
      name ++ " behaves like a " ++ what ++ "!"
```

Nested functions are super helpful for breaking down large problems into smaller ones!

#### Where Challenge
{: .no_toc }

Fill in the blanks to create the `isPrime` function.

```haskell
-- returns True if n is prime
isPrime :: Int -> Bool
isPrime n =
  checkDivisors n (n-1)
where
  checkDivisors n divisor
  | divisor == ____         = True
  | n `mod` divisor == ____ = ______
  | otherwise = checkDivisors n ___________

```

<details>
<summary><b>Answer</b></summary>
<pre>
-- returns True if n is prime
isPrime :: Int -> Bool
isPrime n =
  checkDivisors n (n-1)
where
  checkDivisors n divisor
  | divisor == 1         = True
  | n `mod` divisor == 0 = False
  | otherwise            = checkDivisors n (divisor-1)

</pre>
</details>

## Composite Data Types

We'll dive into a few composite types:

- a **`Tuple`** is a **fixed-size** collection of values; each value can be any type.
- a **`List`** is a sequence of values; **each value must be the same type**.

Let's see some examples in action.

### Tuples

You might have been exposed to tuples before (whether it was in another language or a math class), and they're pretty much what you'd expect here. They let us group related data (of possibly varying types) into a single value. We often use tuples for simple temporary groupings of data e.g. to return multiple values from a function.

```console
ghci> school_and_rank = ("UCLA", 1)
ghci> true_wonder = (True, 1, "der")
ghci> fst school_and_rank
"UCLA"
ghci> snd school_and_rank
1
```

You can see that we define tuples by surrounding a comma separated list of values with parentheses. In order to retrieve the first item from a 2-tuple, we use `fst`. We can use `snd` to retrieve the second. 

{: .warning}
Note that `fst` and `second` only work on tuples of length 2! To retrieve values from larger tuples, you'll need to use something called pattern matching, which is a beautiful feature of Haskell that we will get into soon.

Here are some examples of functions that use tuples!

```haskell
-- tuples.hs

-- Halves the value or neg halves it
halveOrNegate :: (Double, String) -> Double
halveOrNegate    t =
    if snd t == "neg"
    then fst t * (-1.0)
    else fst t / 2.0

-- Performs safe division
safeDivide :: Int -> Int -> (Bool, Int)
safeDivide    num    denom
  | denom /= 0 = (True, quotient)
  | otherwise  = (False, 0)
  where
    quotient = num `div` denom

```

Some things to note here:
1. In `halveOrNegate`, we *must* use parenthese to surround negative numbers as in (-1.0).
2. To divide `Ints`, as in `safeDivide`, you use `` `div` ``. You can also use the prefix version of `div` by removing the backticks as in `div 20 5`. The `/` operator only works for floating point values.
3. We use `/=` for not equals!
4. The local binding `quotient` is only evaluated in the case when it is needed i.e. when `denom` is not equal to `0`. This is a result of Haskell's lazy semantics! It comes in handy often in situations like these because it prevents a divide by zero error.
5. We can use a tuple to return multiple values from a function.

One last important thing to note about tuples in general is that their type is defined by three things:
1. the **number** of elements it contains
2. the **types** of each element
3. the **order** of each element

So for example the following are all different types:

```haskell
(True, "hello")
(False, "goodbye", 0)
("hello", 1, True)
```

### Lists

Now moving on to the most important data type in functional programming: lists! Similar to other languages, a list can hold zero or more of the *same* type. Note that **they are not arrays**: they have `O(N)` access and no pre-defined size.

```hs
--- examples.hs
-- A List of primes
primes :: [Int]
primes = [1,2,3,5,7,11,13]

-- A List of jobs
jobs = ["SWE","Chef","Writer"]

-- A List of Lists
lol = [[1,2,3],[4,5],[6,7,8,9]]

-- A list of tuples
lot = [("foo",1),("bar",2),("boo",3)]

-- An empty list
mt = []
```

The most commonly used list functions are `head` and `tail`; `head` returns the first item of the list, and `tail` returns a list of the rest of the items!

```console
ghci> :load examples
[1 of 1] Compiling Main             ( examples.hs, interpreted )
Ok, one module loaded.
ghci> head primes
1
ghci> tail primes
[2,3,5,7,11,13]
```

Here are some other handly simple list functions.

Is a list empty?

```console
ghci> null []
True
```

Get the list's length:

```console
ghci> length primes
7
```

`take` and `drop` are convenient ways to access slices of a list.

```console
ghci> primes
[1,2,3,5,7,11,13]
ghci> take 3 primes -- return the first 3 elements
[1,2,3]
ghci> drop 4 primes -- return all elements except first 4
[7,11,13]
```

`!!` gives you random access by index:

```console
ghci> jobs
["SWE","Chef","Writer"]
ghci> jobs !! 2
"Writer"
```

`elem` tells you if an item is in a list:

```console
ghci> elem "Chef" jobs
True
```

`sum` adds up the entire list; there's also a corresponding `prod`

```console
ghci> sum primes
42
```

`or` performs boolean `or` over the list; there's also a corresponding `and`

```console
ghci> or [True, False, False]
True
ghci> and [True, False, False]
False

```

`zip` creates tuples out of two lists. This is the same as [python's `zip`](https://docs.python.org/3.9/library/functions.html#zip)!

```console
ghci> zip [10,20,30] jobs
[(10,"SWE"),(20,"Chef"),(30,"Writer")]
```

{: .note}
Like the name may imply, Haskell lists are implemented as singly-linked lists. List operations are implemented recursively! This has performance impacts, since there is no linear random access!

#### Constructing Lists: Ranges
{: .no_toc }

*Ranges* are a neat feature in Haskell that let us easily create lists. (You could think of this behaving similarly to when you drag a cell on Excel/Google Sheets to repeat a pattern.)

```hs
-- example.hs
-- All #s between 1 and 10, inclusive
one_to_ten = [1..10]

-- Odd #s between 1 and 10
oddities = [1,3..10]

-- An infinite list from 42 onward!
whole_lotta_numbers = [42..]

-- An infinite cycle of 1,3,5,1,3,5,…
tricycle = cycle [1,3,5]
```

```console
ghci> :load examples
[1 of 1] Compiling Main             ( examples.hs, interpreted )
Ok, one module loaded.
ghci> one_to_ten
[1,2,3,4,5,6,7,8,9,10]
ghci> oddities
[1,3,5,7,9]
ghci> take 5 whole_lotta_numbers
[42,43,44,45,46]
ghci> take 10 tricycle
[1,3,5,1,3,5,1,3,5,1]
```

Woah ... what's going on with infinite lists? That can't possibly work, right?

Well ... it does! In particular, this goes back to Haskell being **lazily-evaluated**. Haskell won't generate list items from a range *until they're needed*: so, if you never ask for list element #1000 out of the infinite list, Haskell won't care! In other words, **none of the list is initialized when it's initially declared**.

You may then ask some questions:

- can you take the `tail` of an infinite list?
  - **yes, you can**! for example, `tail [42..]` is the same as `[43..]`. You can use `tail [42..]` just like `[42..]`.
- you might be wondering, why does `tail [42..] == [43..]` hang, and `tail [42..]` just keep on printing numbers? What's up with that?
  - well, when `ghci` returns a value, it calls a "print function" on it; the print function for lists keeps on printing until the list is empty.
  - so, when you type in `tail [42..]`, Haskell will keep printing until the list is empty, which is ... never. Hence, wall of text!
  - on the contrary, `tail [42..] == [43..]` hangs because of the **implementation** of the `==` operator, which compares heads until the list is empty.
  - since this never happens, the program doesn't terminate!
- what is the `length` of an infinite list?
  - try it :)

{: .warning }
Be careful when trying it! In particular, Haskell (and all programming languages) [cannot always tell if your program goes into an infinite loop](https://en.wikipedia.org/wiki/Halting_problem). Have your `Ctrl+C` ready!

#### Constructing Lists Challenge
{: .no_toc }

The `++` and `:` operators are used to concatenate elements and lists to create new lists. See if you can guess how these operators work!

```console
ghci> strange = ["stalking", "llamas"]
ghci> strange ++ ["in, "pajamas]
["stalking", "llamas", "in, "pajamas]

ghci> "stealthily" : strange
["stealthily", "stalking", "llamas"]

ghci> "dogs" : []
["dogs"]

ghci> "barking" : "dogs" : []
["barking", "dogs"]
```

As you can see, `++` takes two lists of the *same type* and concatenates them together. The cons operator `:` takes a value and prepends it to the beginning of a list. This value must be the same type as the list elements!

In order to append an item onto the end of a list you can do the following:

```console
ghci> value = ["together"]
ghci> strange ++ value
["stalking", "llamas", "together"]
```

### Strings

Consider the following code operating on strings.

```console
ghci> truth = "Del Taco rules"
ghci> head truth
'D'
ghci> tail truth
'el Taco rules"
ghci> truth ++ "!!!"
"Del Taco rules!!!"
ghci> :t truth
truth :: [Char]
ghci> "hey" == ['h', 'e', 'y']
True
```

These are all list operations. Clearly, strings are just lists of characters!

### List Processing Challenges

Consider the following function that counts the number of items in a list of doubles.

Now, using the count function as an example, complete the product function!

```haskell
count :: [Double] -> Int
count    lst
 | null lst  = 0
 | otherwise =  1 + count (tail lst)

 -- computes the product of all values in a list
prod :: [Double] -> _______
prod    lst
 | null lst  = ________
 | otherwise = ________ * prod __________
```

<details>
<summary><b>Answer</b></summary>
<pre>
prod :: [Double] -> Double
prod    lst
 | null lst  = 1.0
 | otherwise = head lst * prod (tail lst)
</pre>
</details>

Here are a few more examples:

#### Squaring a List
{: .no_toc }
```haskell
-- Return [a^2, b^2, c^2] for input [a, b, c]
sqr_it lst 
 | lst == [] = []
 | otherwise = first_sq : (sqr_it rest)
where
  first_sq = (head lst) ^ 2
  rest = tail lst
```

Some things to notice:
- if our list is empty, that means there's nothing left to square
- otherwise we use the cons operator to concatenate the square of the head to result of applying the funtion to the rest of the list
- classic recursive leap and base case!

#### Reversing a List
{: .no_toc }
```haskell
-- Reverse a list
rev lst
 | lst == [] = []
 | otherwise = (rev rest) ++ [first]
where
  first = head lst
  rest  = tail lst
```

Some things to notice:
- once again, an empty list means there is nothing to reverse. this is our base case!
- otherwise we return the result of reversing the rest of the list with the first element concatenated onto the end. this is the recursive step!
- check out slide 45 if you want a nice visualization of this function in action!

#### Smolest Item Challenge
{: .no_toc }

Fill in the blanks to find the smallest value in a list:

```haskell
-- Find sm0l-est value in a list
sm0lest lst 
 | lst == [] = error "empty list"
 | length lst == 1 = _____
 | otherwise = min first ______________
where
  first = head lst
  rest = tail lst
```

<details>
<summary><b>Answer</b></summary>
<pre>
sm0lest lst 
 | lst == [] = error "empty list"
 | length lst == 1 = first
 | otherwise = min first (sm0lest rest)
where
  first = head lst
  rest = tail lst
</pre>
</details>

And that's all for lecture three! Hopefully you're coming away from it interested and excited to learn more Haskell. It may seem a bit intimidating now, but the more you use it, the more you will appreciate how cool it is!

## Appendix

Everything that follows are notes for the old version of this lecture from last year! It was originally written by the wonderful founding CS 131 TA Matt Wang.

### The Golden Rule of Haskell Indentation
{: .no_toc }

Code which is part of an expression should be indented further in than the beginning of that expression.

You must align the spacing for all items in a group.

**If you don't follow this rule, you'll get some errors!**

Examples:

```hs
mult x y =
  x * y
```

```hs
let
  x = 5
  y = 6
```

```hs
-- note: this is rather uncommon
let x = 5
    y = 6
```

```hs
where
 x = a
 y = b
```

```hs
where x = a
      y = b
```

```hs
case x of
  42 -> foo
  -1 -> bar
```

```hs
if foo
   then bar
   else boo
```

## Data Types in Haskell
{: .no_toc }

### The Type System
{: .no_toc }

Haskell is a **statically typed language**. That means that the type of *all* variables and *all functions* can be figured out at **compile time**

(this is different from Python - a dynamically typed language - where types can only be determined as the program actually runs)

Haskell also has **type inference**: the compiler can figure out the types of most expressions *without you annotating them*! Neat!

(this started in functional programming, and has made its way into mainstream languages like C++'s `auto` keyword)

### Primitive Types
{: .no_toc }

The built-in data types are:

- `Int`: 64-bit signed integers
- `Integer`: arbitrary-precision signed integers
  - aside: how does this work?
  - in languages like Python, we can treat numbers as arrays of `Int`s of a "Base `2^64`" system [^2]
- `Bool`: booleans (`True` or `False`)
- `Char`: characters (like in other languages)
- `Float`: 32-bit (single-precision) floating point
- `Double`: 64-bit (double-precision) floating point

[^2]: for more information, check out [the Wikipedia article](https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic)!

Let's see a live code example of some primitive types:

```hs
-- example.hs
-- Defining an Int
nerds = 150 :: Int

-- Defining an Integer
googleplex = 10^100 :: Integer

-- Defining a Float
rootbeer = 3.14159 :: Float

-- Defining a Bool
carey_has_hair = False :: Bool
```

When we enter just the name of a variable, `ghci` will print its value for us:

```console
ghci> :load examples
[1 of 1] Compiling Main             ( examples.hs, interpreted )
Ok, one module loaded.
ghci> googleplex
10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
```

`:t` tells us the type of the expression passed to it. This is **really, really useful**: it's a helpful tool to learn more about the language and its type inference rules!

```hs
ghci> :t googleplex
googleplex :: Integer
```

### Operators
{: .no_toc }

Haskell supports operators you're used to: `+`, `-`, `*`, `/`, `^`, etc.

But, there's a few caveats!

This works well:

```console
ghci> :load examples
[1 of 1] Compiling Main             ( examples.hs, interpreted )
Ok, one module loaded.
ghci> 42 + nerds * 10
1542
```

In Haskell, the `/` division operator **does not work on Integers**! (why might that be - there's a good functional reason!)

```console
ghci> nerds / 10
<interactive>:3:7: error:
    • No instance for (Fractional Int) arising from a use of ‘/’
    • In the expression: nerds / 10
      In an equation for ‘it’: it = nerds / 10
```

You must use `` `div` `` instead.

```console
ghci> nerds
150
ghci> nerds `div` 10
15
```

However, `/` works on floats just fine:

```console
ghci> rootbeer
3.14159
ghci> rootbeer / 10
0.314159
```

To make numbers negative, you need to add a parentheses: this makes `-` a *unary operator*:

```console
ghci> nerds
150
ghci> nerds + (-1)
149
```

There is prefix notation for infix operators:

```console
ghci> rootbeer
3.14159
ghci> (+) rootbeer 1.0
4.14159
```

Boolean operators generally work like how you'd expect!

```console
ghci> nerds
150
ghci> carey_has_hair
False
ghci> nerds > 100 && not carey_has_hair
True
```

### Composite Types
{: .no_toc }

We'll dive into three composite types:

- a **`Tuple`** is a **fixed-size** collection of values; each value can be any type.
- a **`List`** is a sequence of values; **each value must be the same type**.
- a **`String`** is a list of characters!

Let's see some examples in action.

#### Tuples
{: .no_toc }

Tuples are great for associating values together, or having a function "return multiple values".

```hs
--- examples.hs
-- A Tuple for a student's score
grade = ("Sergey", 97)

-- A job posting: title, wage, hrs/wk
job = ("Chef", 35.5, 40)

-- A tuple with tuples, lists & ints
whoa = ((1,"two"),['a','b','c'], 17)
```

```console
ghci> :load examples
[1 of 1] Compiling Main             ( examples.hs, interpreted )
Ok, one module loaded.
ghci> grade
("Sergey",97)
ghci> fst grade
"Sergey"
ghci> snd grade
97
```

{: .warning }
`fst` and `snd` are only defined for tuples with two elements! They do not work for tuples with 3 or more elements - you'd use pattern matching instead (coming next lecture)!

What *is* the type of the Tuple? Let's ask ghci:

```console
ghci> :t grade
grade :: (String, Integer)
```

Interesting! Note that the type of the tuple encodes:

- **the number of elements in the tuple**
- **the types of each element in the tuple**

This means, for example, that you can't have a list of any two tuples - they must all be tuples of the same size and types!

{: .note }
And that's all for this lecture! Happy Haskelling :)

## Functions
{: .no_toc}
### Our First Haskell Function
{: .no_toc}
Haskell functions have three core components:

1. (optional): type information about the function's **parameters** and **return value**
2. the **function name** and **parameter** names
3. an **expression** that defines the function's behaviour


Here's a simple function in C++:

```cpp
String insult(String name, String smell) {
  String s = name + " smells like " +
             smell + " and doesn't floss.";
  return s;
}
```

And here's how we'd define the same function in Haskell:

```hs
insult :: String -> String -> String
insult name smell =
  name ++ " smells like " ++ smell ++ " and doesn't floss."
```

Some things to note:

- there's no explicit `return` since the right-hand side of a function *is* what it returns!
- spaces and indentation are used to define code blocks; no braces necessary (think Python)
- `String -> String -> String` may seem strange - it seems like there's no difference between parameters and return types. We'll talk about this later when we discuss **currying**.

{: .note }
Here's an example of how to write multiline functions within `ghci`:

```console
ghci> :{
ghci| insult name smell =
ghci|   name ++
ghci|   " smells like " ++
ghci|   smell ++
ghci|   " and doesn't floss."
ghci| :}
ghci> insult "carey" "cheese"
"carey smells like cheese and doesn't floss."
```

### Optional Type Declarations
{: .no_toc}
Type declaration is optional because of Haskell's type inference! How does it work?

```hs
insult :: String -> String -> String
insult name smell =
  name ++ " smells like " ++ smell ++ " and doesn't floss."
```

- we can only concatenate (`++`) lists, so we know `name` and `smell` are some type of list
- `" smells like "` and `" and doesn't floss."` are lists of characters (recall that `String = [Char]`)
- since we can only concatenate lists of the same type, `name` and `smell` are `String`s!!
- the concatenation of `String`s is `String`, and thus `insult` returns a `String`

So ... why would we even use type declarations? Unlike who we're insulting, it's **good hygiene** (and, best practice)!

- type declarations can provide better compiler warnings and errors
- type declarations make your code **easier to read**
  - arguably the most important trait in software
  - the person reading it may be you six months later!
- and, it can help you think about how to write the function itself!

So, we recommend that you annotate your functions - or at least, the user-facing/top-level ones!

### Main Functions and (avoiding) Monads
{: .no_toc}
{: .note }
This is intentionally hand-wavy. We won't be covering [monads](https://en.wikipedia.org/wiki/Monad_(functional_programming)) or impure FP at all in this class.

What we haven't talked about yet is the *main function* - in other words, how can we have Haskell run a function when we open a file?

(and, while we're at it, how can we get user input - which **is a side effect**?)

To do it, we'll create a function called `main`, and annotate it with the `IO()` "type" (really - [a system and monad](https://www.haskell.org/tutorial/io.html)). We then add this strange `do` block, and write what seems like imperative code:

```hs
-- insult.hs
insult :: String -> String -> String
insult name smell =
  name ++ " smells like " ++ smell ++ " and doesn't floss."

main::IO()
main = do
  putStr "What is your name? "
  name <- getLine
  putStrLn (insult name "unwashed dog")
```

We can then call our `main` function and get some input.

```console
ghci> :load insult
[1 of 1] Compiling Main             ( insult.hs, interpreted )
Ok, one module loaded.
ghci> main
What is your name? Carey
Carey smells like unwashed dog and doesn't floss.
```

Is this hand-wavy? Yes! IO (and monads, a way to deal with side effects) is not a focus for this class. If you're interested, we suggest:

- taking CS 231 (here are some [wonderful notes from Galen Wong](https://galenwong.github.io/blog/2021-08-29-cs231-notes/))
- read the Learn You a Haskell chapters on [IO](http://learnyouahaskell.com/input-and-output) and [Monads](http://learnyouahaskell.com/a-fistful-of-monads)

### More Examples!
{: .no_toc}
Let's see some other examples!

```hs
isBigger :: Double -> Double -> Bool
isBigger a b = a > b
```

```hs
average :: [Double] -> Double
average list =
  (sum list) / fromIntegral (length list)
```

{: .note }
Here, we use `fromIntegral` to cast the value of `length` to a type that we can divide with. In this case it maps from `Integral -> Double`. In general, we can use `fromIntegral` to map any `Integral` type (i.e. `Int` or `Integer`) to any `Num` type.

This last example showcases the power of Haskell's type system:

```hs
get_last_item :: [any_type] -> any_type
get_last_item lst =
  head (reverse lst)
```

This function works for a list of any type! So, *Haskell doesn't care what type it is*. The `any_type` is a **type variable**, which we can think of as a generic or template type. We'll refine this notion in a later lecture.

What's cool is that we didn't have to do anything special - it just works out of the box! **And, we didn't even need to tell Haskell that it's generic**: the type system figured it out by itself!

{: .note }
You may be thinking to yourself: is this polymorphism (or generic programming) at runtime, or is a copy of this function generated for each type? In Haskell, it's the former: there is one version of the language that "just works" for all types. This is similar to how Java does it. In other languages, like C++ or Rust, generics are compile-time: a copy of the function is made for each type that uses it (this is called [monomorphization](https://rustc-dev-guide.rust-lang.org/backend/monomorph.html)). We will be learning more about the different types of generic programming later on in the class!

### Practice Problem
{: .no_toc}
In class, we went over a brain teaser. Consider:

```hs
f :: Int -> Int
f x = x^2

g :: Int -> Int
g x = 3 * x
```

What do the following two lines do?

```hs
y = f g 2
z = f 5 * 10
```

Well, it turns out:

- `y = f g 2` is a **syntax error**!
  - Haskell evaluates functions **from left to right** (keyword: **left-associative**)
  - so, `f g 2` is the same as `((f g) 2)`, which doesn't make sense - since `f` doesn't operate on functions
- `f 5 * 10 = 250`
  - in Haskell, functions have higher precedence than operators, so they're always evaluated first
  - in other words, this is `(f 5) * 10`

```hs
-- f(g(x))
compute_f_of_g x = f (g x)

-- f(x * 10)
compute_f_of_x_times_ten x = f (x * 10)
```

{: .note }
If you're curious, the [Haskell spec defines operator precedence](https://www.haskell.org/onlinereport/decls.html#sect4.4.2) (and, how associativity works).

## Local Bindings
{: .no_toc}
This time, the majority of topics we cover are so called "syntactic sugar" in Haskell. They can make the programming easier. When we write code, sometime it is helpful to create "temporary variables" to simplify the code. In Haskell, it is achieved with `let` and `where` constructs.

### The `let` keyword
{: .no_toc}
Here's an example that demonstrates how to use `let`:

```hs
-- let.hs
get_nerd_status gpa study_hrs =
  let
      gpa_part = 1 / (4.01 - gpa)
      study_part = study_hrs * 10
      nerd_score = gpa_part + study_part
  in
      if nerd_score > 100 then
           "You are super nerdy!"
      else "You're a nerd poser."
```

The `let` construct consists of two parts:

- the first part is between the `let` and the `in`; here, you define one or more "bindings" to associate a name with an expression
  - for example, the third line of the function binds the name `gpa_part` to the expression `1 / (4.01 - gpa)`.
- the second part follows `in`; it contains an expression where the bindings are used.

The bindings are immutable variables - you can't change them!

### The `where` keyword
{: .no_toc}
The `where` keyword is similar; it just changes the syntax. With `where`, you first write the code, then specify the bindings after the `where` keyword. The equivalent example is:

```hs
-- let.hs
get_nerd_status gpa study_hrs =
  if nerd_score > 100
     then "You are super nerdy!"
     else "You're a nerd poser."
  where
      gpa_part = 1 / (4.01 - gpa)
      study_part = study_hrs * 10
      nerd_score = gpa_part + study_part
```

When would you use `let` and when do you use `where`? A nice rule of thumb is:

- when defining bindings (variables) for *a single expression* (e.g. the example here), either one is fine
- when defining bindings for use *across multiple expressions*, use `where`

{: .note }
The second case is mainly for *guards* and *case* statements. We haven't learned them yet but we will see them shortly. It's also more of an opinion - :)

### Nested functions with `let` or `where`
{: .no_toc}
We can also use `let` and `where` to define _nested functions_:

```hs
-- nestfunc.hs
whats_the_behavior_of name =
 if name == "Carey"
    then behaves_like name "twelve year-old"
    else behaves_like name "grown-up"
 where
   behaves_like n what =
      n ++ " behaves like a " ++ what ++ "!"
```

This is very helpful in breaking down bigger problems into small, reusable functions -- and helps us with naming!

Nested functions can use all of their enclosing function's bindings. So, we can make our example more concise by using `name`:

```hs
-- nestfunc.hs
-- Function to describe someone's behavior
whats_the_behavior_of name =
 if name == "Carey"
    then behaves_like "twelve year-old"
    else behaves_like "grown-up"
 where
   behaves_like what =
      name ++ " behaves like a " ++ what ++ "!"
```

### Lazy execution with `let` and `where`
{: .no_toc}
In the previous lecture, we touched on [Haskell's lazy evaluation for lists]({{site.baseurl}}/lectures/02/#creating-lists-ranges). This also applies to `let` and `where`: bindings are **not evaluated when they are defined; only when they are actually used**!

```hs
potentially_slow_func arg =
  let
      val1 = really_slow_function arg
      val2 = very_fast_function arg
      val3 = pretty_fast_function arg
  in
      if val3 > 100 then val1
                    else val2
```

Haskell's behavior when running the code above is:

- in the `let` block, Haskell binds `val1`, `val2`, and `val3` to the expressions - but *doesn't* evaluate them!
- when the function body runs, the `if` condition requires `val3`.
- so, Haskell evaluates the expression associated with `val3`, calling `pretty_fast_function`.
- then, *only one* of `val1` and `val2` will evaluate.
- so, if `pretty_fast_function` returns 20, then we go to the `else` branch. To compute `val2` `very_fast_function` is called. We will _never_ call `really_slow_function` in this case!

Note that Haskell doesn't have to re-evaluate the binding every time it's used - after doing it once, it can just cache it!

{: .note}
Laziness can be confusing with IO, since the sequence of IO actually matters!. Haskell's solution is to disallow IO (and other side-effects) to happen in normal code. Try to think about what will happen if the code below is valid in Haskell.

```hs
-- Which getLine will run first?!?!
laziness_example arg =
  let
      val1 = getLine
      val2 = getLine
  in
      if arg > 100 then val1 + val2
                   else val2 * val1
```

## Control Flow
{: .no_toc}
We've been using some control flow features already, but we haven't formalized them. Let's do that now!

### `if`-`then`-`else`
{: .no_toc}
The general syntax of the `if` statement (or more precisely, expression) is:

```hs
if <expression> then <expression>
                else <expression>
```

For example:

```hs
ageist_greeting age =
  if age > 30 then "Hey boomer!"
              else "Hey fam!"
```

A key insight is that **every `if` statement must have an accompanying `else`**. If there *wasn't* an `else`, and we didn't take the `if` - our function wouldn't return anything. That's not allowed!

{: .note}
Think about how `if`-`then`-`else` works with types - if the two branches had different types, we'd break some of Haskell's type rules. This formalizes the above argument - why is that?

### Guards
{: .no_toc}
Guards are a compact verison of the `if-then` expression (but really, are just syntactic sugar).

It allows us to write

```hs
if <condition> then <expr>
```

as

```hs
  | <condition> = <expr>
```

We can define a function as a series of one or more guards, like

```hs
somefunc param1 param2
  | <if-x-is-true> = <run-this>
  | <if-y-is-true> = <run-that>
  | <if-z-is-true> = <run-the-other>
  | otherwise = <run-this-otherwise>
```

A real example in Haskell:

```hs
major_guesser salary
  | salary > 150000 = "CS"
  | salary > 120000 = "EE"
  | salary < 30000 = "Any major at USC"
  | otherwise = "Probably Poli-sci"
```

Note:

- we don't need the equal sign after defining the function!
- each guard begins with the pipe character: `|`
- after that, the guard contains two parts:
  - the first part is a _boolean expression_; we want to evaluate to see if it is `True`.
  - the second part is the "payload" expression. It will return if the expression is `True`.
- Haskell evaluates all of the guards **from top to bottom**, and returns the payload of the first guard that is `True`.

{: .note}
In guards, `otherwise` acts like a wildcard. In fact, `otherwise` evaluates to `True` (try it in `ghci`)!

Let's take a look at some examples:

```hs
-- Factorial using if/then
fact n =
  if n <= 0 then 1
            else n * fact (n-1)

-- Factorial using guards
fact n
 | n == 0 = 1
 | otherwise = n * fact (n-1)

-- Find sm0l-est value in a list
sm0lest lst
 | lst == [] = error "empty list"
 | length lst == 1 = first
 | otherwise = min first (sm0lest rest)
 where
   first = head lst
   rest = tail lst
```

Note that in the last example, the values defined in the `where` clause are used by multiple guards.

We can use guard to implement quicksort in _eight_ lines of code (or less!). The following implementation uses `where`, guards, and list comprehensions:

```hs
qsort lst
 | lst == [] = []
 | otherwise = less_eq ++ [pivot] ++ greater
 where
    pivot = head lst
    rest_lst = tail lst
    less_eq = qsort [a | a <- rest_lst, a <= pivot]
    greater = qsort [a | a <- rest_lst, a > pivot]
```

Neat!

------
## Footnotes
{: .no_toc}
